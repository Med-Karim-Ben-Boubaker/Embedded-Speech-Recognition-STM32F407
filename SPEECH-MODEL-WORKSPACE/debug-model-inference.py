"""
Log Mel Spectrogram Inference Script for STM32F407G-Discovery Board

This script is designed to accept log Mel spectrograms generated by the preprocessing library 
on the STM32F407G-Discovery board. It processes 1 second's worth of audio data and runs 
inference using a TensorFlow Lite model. The script also plots the received spectrogram 
and the results of the inference for visualization.

Requirements:
- Ensure that the STM32F407G-Discovery board is configured to send log Mel spectrogram data 
  over USB.
- The necessary firmware for the STM32F407G-Discovery board is available at the following 
  GitHub repository:
  [https://github.com/Med-Karim-Ben-Boubaker/Discovery-STM32F407-Audio-Acquisition]

Script Details:
- The script establishes serial communication with the STM32 board to receive audio data.
- It constructs a spectrogram from the received data and performs inference using a pre-trained 
  TensorFlow Lite model.
- The received spectrogram is plotted alongside the inference results, displaying class 
  probabilities in a bar chart.

Configuration:
- Serial Port: COM10
- Baud Rate: 9500
- Timeout: 2 seconds
- FFT Length: 512
- Number of Frames: 122
- Spectrogram Sample Size: 40

Author: Ben Boubaker Mohamed Karim
Date: 2024-Aug
"""

import serial
import struct
import numpy as np
import matplotlib.pyplot as plt
from enum import Enum
import tensorflow as tf  # Add this import for TensorFlow

# Variables Declaration ----------------------------------------------------------------------

# Initialize serial communication
# Set up the serial port with the specified port name, baud rate, and timeout
ser = serial.Serial('COM10', 9500, timeout=2)

# Define constants
FFT_LEN = 512 # Length of the Fast Fourier Transform
FRAME_NUM = 122 # Number of frames in the spectrogram
AUDIO_PCM_BUFFER_SIZE = 16000 # Buffer size for storing audio PCM data
SPECTROGRAM_SAMPLE_SIZE = 40 # Size of the spectrogram sample

# Load the TFLite model
interpreter = tf.lite.Interpreter(model_path="models/model_no_quant.tflite")
interpreter.allocate_tensors()

# Get input and output tensors from the TFLite model
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()


# Utility Functions ----------------------------------------------------------------------

def read_usb_data_f32():
    """Read 4 bytes from the USB serial port and unpack them as a float.

    Returns:
        float: The unpacked float value from the USB data.
    """
    usb_bytes = ser.read(4)  # Read 4 bytes from the serial port
    if len(usb_bytes) == 4:
        usb_value = struct.unpack('f', usb_bytes)[0]  # Unpack the float value
        return usb_value 

def read_usb_data_int8():
    """Read 1 byte from the USB serial port and unpack it as an unsigned byte.

    Returns:
        int: The unpacked unsigned byte value from the USB data.
    """
    usb_bytes = ser.read(1)  # Read 1 byte from the serial port
    if len(usb_bytes) == 1:
        usb_value = struct.unpack('B', usb_bytes)[0]  # Unpack the float value
        return usb_value
    else:
        return None
    
def construct_spectrogram():
    """Constructs a spectrogram matrix by reading data from USB.

    Returns:
        np.ndarray or None: The constructed spectrogram matrix, or None if the process failed.
    """
    spectrogram_matrix = np.zeros((SPECTROGRAM_SAMPLE_SIZE, FRAME_NUM), dtype=np.float32)
    spectrogram_updated = 0 # Flag to check if the spectrogram was updated
    
    for col in range(FRAME_NUM):
        for row in range(SPECTROGRAM_SAMPLE_SIZE):
            
            value = read_usb_data_f32()
            
            if value is not None or value != 0.0:
                spectrogram_updated = 1
                spectrogram_matrix[row, col] = value
            
            else:
                spectrogram_updated = 0
                break # Break if a value is None or 0.0
            
        if not (value is not None or value != 0.0):
            break
            
    if spectrogram_updated == 1:
        return spectrogram_matrix
    
    else:
        return None

def plot_spectrogram(spectrogram_matrix, ax):
    """Plot the spectrogram matrix using Matplotlib.

    Args:
        spectrogram_matrix (np.ndarray): The spectrogram matrix to plot.
        ax (matplotlib.axes.Axes): The axes on which to plot the spectrogram.
    """
    ax.clear()  # Clear the previous plot
    ax.imshow(spectrogram_matrix, aspect='auto', origin='lower', cmap='viridis')
    ax.set_xlabel('Time (columns)')
    ax.set_ylabel('Frequency (rows)')
    ax.set_title('Spectrogram')
    plt.draw()
    plt.pause(0.5)  # Pause to update the plot

def new_data_received(max_attempts=10):
    """Check if new data is received by reading values from USB.

    Args:
        max_attempts (int): The maximum number of attempts to check for data.

    Returns:
        bool: True if 10 consecutive zeros are received, otherwise False.
    """
    zero_count = 0
    value = None
    
    for _ in range(max_attempts):
        value = read_usb_data_f32()
        
        if value is None:
            print("No data received. Retrying...")
            continue  # Skip the rest of the loop if no data is received
        
        if value == 0.0:
            zero_count += 1
        else:
            break  # Exit the loop if we receive a non-zero value
    
    # Return True if we received 10 consecutive zeros, otherwise False
    return zero_count == max_attempts

def run_inference(spectrogram):
    """Run inference on the given spectrogram using the TFLite model.

    Args:
        spectrogram (np.ndarray): The spectrogram matrix for inference.

    Returns:
        np.ndarray or None: The output data from the model, or None if there is an input shape mismatch.
    """
    # Crop to 122 frames if necessary
    if spectrogram.shape[1] != 122:
        print(f"Spectrogram shape mismatch. Expected width of 122, got {spectrogram.shape[1]}")
        spectrogram = spectrogram[:, :122]
    
    # Preprocess the input (add batch dimension and channel dimension)
    input_data = np.expand_dims(spectrogram, axis=0).astype(np.float32)  # Add batch dimension
    input_data = np.expand_dims(input_data, axis=-1)  # Add channel dimension

    # Rearrange dimensions to match model input shape [1, 122, 40, 1]
    input_data = np.transpose(input_data, (0, 2, 1, 3))
    
    # Check if the input shape matches the model's expected input shape
    if input_data.shape != tuple(input_details[0]['shape']):
        print(f"Input shape mismatch. Expected {input_details[0]['shape']}, got {input_data.shape}")
        return None

    # Set the input tensor
    interpreter.set_tensor(input_details[0]['index'], input_data)

    # Run inference
    interpreter.invoke()

    # Get the output tensor
    output_data = interpreter.get_tensor(output_details[0]['index'])

    return output_data

# Main Application ----------------------------------------------------------------------

def main():
    # Set print options to print the entire matrix
    np.set_printoptions(threshold=np.inf, linewidth=np.inf)
    plt.ion()  # Turn on interactive mode
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))
    
    while True:
        if (new_data_received()):
            # Construct logMelSpectrogram
            spectrogram_matrix = construct_spectrogram()
            
            if spectrogram_matrix is not None:
                plot_spectrogram(spectrogram_matrix, ax1)
                
                # Run inference
                inference_result = run_inference(spectrogram_matrix)
                
                if inference_result is not None:
                    # Plot or process the inference result
                    ax2.clear()
                    probabilities = inference_result[0]
                    classes = range(len(probabilities))
                    
                    # Plot probabilities as a bar chart
                    bars = ax2.bar(classes, probabilities)
                    ax2.set_title('Inference Result')
                    ax2.set_xlabel('Class')
                    ax2.set_ylabel('Probability')

                    # Annotate bars with probability values
                    for bar, probability in zip(bars, probabilities):
                        ax2.text(
                            bar.get_x() + bar.get_width() / 2, # X position (center of bar)
                            bar.get_height(),                  # Y position (top of bar)
                            f"{probability:.2f}",              # Probability text
                            ha='center',                       # Horizontal alignment
                            va='bottom'                        # Vertical alignment
                        )

                    plt.draw()
                    plt.pause(0.1)

                    # Print all class probabilities
                    for cls, prob in enumerate(probabilities):
                        print(f"Class {cls}: Probability {prob:.4f}")

                    # Print the top prediction
                    top_prediction = np.argmax(probabilities)
                    print(f"Top prediction: Class {top_prediction} with probability {probabilities[top_prediction]:.4f}")
                else:
                    print("Inference failed.")


if __name__ == "__main__":
    main()